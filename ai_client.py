"""
ai_client

A small, self-contained OpenAI client wrapper for generating asset-class outlooks.
- Requires a user-provided API key supplied by the front-end.
- Validates and normalizes the model response into a structured dict.
- Default model: gpt-4o-mini.

This specific client was heavily generated by GPT-5.1-Codex-Max

Katalepsis-lab 2025
"""

from __future__ import annotations

import json
from typing import Any, Dict, Iterable

from openai import OpenAI

MODEL_NAME = "gpt-4o-mini"
ALLOWED_LEVELS: tuple[str, ...] = ("low", "medium", "high")
REQUIRED_KEYS: tuple[str, ...] = ("equities", "fixed_income", "commodities", "alternatives", "cash", "justification")
JUSTIFICATION_MAX_CHARS = 800


class InvalidResponseFormat(Exception):
    """Raised when the model response cannot be parsed or validated."""


def _build_prompt(prompt: str) -> str:
    """Wrap the user's outlook prompt with instructions for structured output."""
    return (
        "Read the economic outlook and return a JSON object with exactly these keys: "
        "equities, fixed_income, commodities, alternatives, cash, justification.\n"
        f"- For equities/fixed_income/commodities/alternatives/cash: value must be a lowercase string: {', '.join(ALLOWED_LEVELS)}.\n"
        f"- For justification: value must be a plain string (max {JUSTIFICATION_MAX_CHARS} characters).\n"
        "- Do not include any keys other than those listed.\n"
        "- Do not include markdown, code fences, comments, or prose outside the JSON.\n\n"
        f"Economic outlook:\n{prompt.strip()}"
    )


def _asset_outlook_response_format() -> Dict[str, Any]:
    return {
        "type": "json_schema",
        "name": "asset_class_outlook",
        "strict": True,
        "schema": {
            "type": "object",
            "additionalProperties": False,
            "required": list(REQUIRED_KEYS),
            "properties": {
                "equities": {"type": "string", "enum": list(ALLOWED_LEVELS)},
                "fixed_income": {"type": "string", "enum": list(ALLOWED_LEVELS)},
                "commodities": {"type": "string", "enum": list(ALLOWED_LEVELS)},
                "alternatives": {"type": "string", "enum": list(ALLOWED_LEVELS)},
                "cash": {"type": "string", "enum": list(ALLOWED_LEVELS)},
                "justification": {"type": "string", "minLength": 1, "maxLength": JUSTIFICATION_MAX_CHARS},
            },
        },
    }


def _parse_model_response(content: str) -> Dict[str, str]:
    """Parse and validate the model JSON response."""
    try:
        payload = json.loads(content)
    except json.JSONDecodeError as exc:
        raise InvalidResponseFormat(f"Model response is not valid JSON: {exc}") from exc

    missing = [k for k in REQUIRED_KEYS if k not in payload]
    if missing:
        raise InvalidResponseFormat(f"Missing keys in response: {', '.join(missing)}")

    allowed_levels = set(ALLOWED_LEVELS)
    validated = {}
    for key in REQUIRED_KEYS:
        if key == "justification":
            if not isinstance(payload[key], str) or not payload[key].strip():
                raise InvalidResponseFormat("justification must be a non-empty string")
            validated[key] = payload[key].strip()[:JUSTIFICATION_MAX_CHARS]
            continue

        value = str(payload[key]).lower().strip()
        if value not in allowed_levels:
            raise InvalidResponseFormat(
                f"Invalid level for {key}: {payload[key]!r}. Expected one of: {', '.join(sorted(allowed_levels))}."
            )
        validated[key] = value

    return validated


def _is_nonempty_string(value: object) -> bool:
    return isinstance(value, str) and bool(value.strip())


def _first_nonempty(items: Iterable[str | None]) -> str | None:
    for item in items:
        if _is_nonempty_string(item):
            return item.strip()
    return None


def generate_outlook(prompt: str, user_api_key: str) -> Dict[str, str]:
    """
    Generate a structured asset-class outlook via OpenAI.

    Args:
        prompt: The economic outlook prompt provided by the user.
        user_api_key: User-supplied OpenAI API key from the front-end.

    Returns:
        A dictionary with equities, fixed_income, commodities, alternatives, cash, and justification.

    Raises:
        InvalidResponseFormat: When the model response is malformed or missing fields.
        openai.OpenAIError: For underlying API errors.
        ValueError: If the prompt or API key is empty.
    """
    if not prompt or not prompt.strip():
        raise ValueError("Prompt must be a non-empty string")

    if not _is_nonempty_string(user_api_key):
        raise ValueError("An OpenAI API key is required")

    client = OpenAI(api_key=user_api_key)

    last_error: Exception | None = None
    for attempt in range(2):
        response = client.responses.create(
            model=MODEL_NAME,
            instructions="You are an investment assistant. Follow the response schema strictly.",
            input=_build_prompt(prompt),
            text={"format": _asset_outlook_response_format()},
            temperature=0.2 if attempt == 0 else 0.0,
            max_output_tokens=300,
            timeout=30,
        )

        content = _first_nonempty([getattr(response, "output_text", None)])
        if not content:
            last_error = InvalidResponseFormat("Model returned empty content")
            continue

        try:
            return _parse_model_response(content)
        except InvalidResponseFormat as exc:
            last_error = exc

    assert last_error is not None
    raise last_error
